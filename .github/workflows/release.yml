name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., 0.1.0)'
        required: true
        type: string

env:
  CARGO_TERM_COLOR: always

jobs:
  create-release:
    permissions:
      contents: write
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for changelog generation

      - name: Get version from tag
        id: get_version
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "VERSION=${{ inputs.version }}" >> $GITHUB_OUTPUT
          else
            echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
          fi

      - name: Generate changelog from commits
        id: changelog
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"

          # Get the previous tag to determine commit range
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -n "$PREV_TAG" ]; then
            COMMIT_RANGE="${PREV_TAG}..HEAD"
          else
            # First release - get all commits
            COMMIT_RANGE="HEAD"
          fi

          # Extract conventional commits and categorize them
          echo "## Downloads" > /tmp/release_notes.md
          echo "" >> /tmp/release_notes.md
          echo "| Platform | File | Notes |" >> /tmp/release_notes.md
          echo "|----------|------|-------|" >> /tmp/release_notes.md
          echo '| **macOS (Apple Silicon)** | `TARS_*_aarch64.dmg` | M1/M2/M3/M4 Macs |' >> /tmp/release_notes.md
          echo '| **macOS (Intel)** | `TARS_*_x64.dmg` | Intel-based Macs |' >> /tmp/release_notes.md
          echo '| **Windows** | `TARS_*_x64-setup.exe` | Windows 10/11 (64-bit) |' >> /tmp/release_notes.md
          echo '| **Windows (MSI)** | `TARS_*_x64_en-US.msi` | Alternative installer |' >> /tmp/release_notes.md
          echo '| **Linux (Debian/Ubuntu)** | `TARS_*_amd64.deb` | `sudo dpkg -i <file>` |' >> /tmp/release_notes.md
          echo '| **Linux (Universal)** | `TARS_*_amd64.AppImage` | Make executable, then run |' >> /tmp/release_notes.md
          echo '| **Linux (Fedora/RHEL)** | `TARS_*_x86_64.rpm` | `sudo rpm -i <file>` |' >> /tmp/release_notes.md
          echo "" >> /tmp/release_notes.md

          # Get features (feat:)
          FEATURES=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "^feat(\(.+\))?!?:" | sed -E 's/^feat(\([^)]+\))?!?: /- /' || true)
          if [ -n "$FEATURES" ]; then
            echo "## Features" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
            echo "$FEATURES" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
          fi

          # Get fixes (fix:)
          FIXES=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "^fix(\(.+\))?!?:" | sed -E 's/^fix(\([^)]+\))?!?: /- /' || true)
          if [ -n "$FIXES" ]; then
            echo "## Bug Fixes" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
            echo "$FIXES" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
          fi

          # Get performance improvements (perf:)
          PERF=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "^perf(\(.+\))?!?:" | sed -E 's/^perf(\([^)]+\))?!?: /- /' || true)
          if [ -n "$PERF" ]; then
            echo "## Performance" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
            echo "$PERF" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
          fi

          # Get breaking changes (anything with !)
          BREAKING=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "^[a-z]+(\(.+\))?!:" | sed -E 's/^[a-z]+(\([^)]+\))?!: /- **BREAKING:** /' || true)
          if [ -n "$BREAKING" ]; then
            echo "## Breaking Changes" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
            echo "$BREAKING" >> /tmp/release_notes.md
            echo "" >> /tmp/release_notes.md
          fi

          echo "CHANGELOG_FILE=/tmp/release_notes.md" >> $GITHUB_OUTPUT

      - name: Update CHANGELOG.md
        run: |
          VERSION="${{ steps.get_version.outputs.VERSION }}"
          DATE=$(date +%Y-%m-%d)

          # Get the previous tag to determine commit range
          PREV_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")

          if [ -n "$PREV_TAG" ]; then
            COMMIT_RANGE="${PREV_TAG}..HEAD"
          else
            COMMIT_RANGE="HEAD"
          fi

          # Generate changelog content for CHANGELOG.md
          echo "" > /tmp/changelog_entry.md
          echo "## [${VERSION}] - ${DATE}" >> /tmp/changelog_entry.md
          echo "" >> /tmp/changelog_entry.md

          # Get features (feat:)
          FEATURES=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "^feat(\(.+\))?!?:" | sed -E 's/^feat(\([^)]+\))?!?: /- /' || true)
          if [ -n "$FEATURES" ]; then
            echo "### Added" >> /tmp/changelog_entry.md
            echo "$FEATURES" >> /tmp/changelog_entry.md
            echo "" >> /tmp/changelog_entry.md
          fi

          # Get fixes (fix:)
          FIXES=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "^fix(\(.+\))?!?:" | sed -E 's/^fix(\([^)]+\))?!?: /- /' || true)
          if [ -n "$FIXES" ]; then
            echo "### Fixed" >> /tmp/changelog_entry.md
            echo "$FIXES" >> /tmp/changelog_entry.md
            echo "" >> /tmp/changelog_entry.md
          fi

          # Get performance improvements (perf:)
          PERF=$(git log $COMMIT_RANGE --pretty=format:"%s" | grep -E "^perf(\(.+\))?!?:" | sed -E 's/^perf(\([^)]+\))?!?: /- /' || true)
          if [ -n "$PERF" ]; then
            echo "### Performance" >> /tmp/changelog_entry.md
            echo "$PERF" >> /tmp/changelog_entry.md
            echo "" >> /tmp/changelog_entry.md
          fi

          # Insert new entry after the header (line 7 in CHANGELOG.md)
          head -n 7 CHANGELOG.md > /tmp/changelog_new.md
          cat /tmp/changelog_entry.md >> /tmp/changelog_new.md
          tail -n +8 CHANGELOG.md >> /tmp/changelog_new.md
          mv /tmp/changelog_new.md CHANGELOG.md

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Commit and push
          git add CHANGELOG.md
          git commit -m "chore: update CHANGELOG.md for v${VERSION}" || echo "No changes to commit"
          git push origin HEAD:main || echo "Nothing to push"

      - name: Create Release
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.event_name == 'workflow_dispatch' && format('v{0}', inputs.version) || github.ref_name }}
          name: TARS v${{ steps.get_version.outputs.VERSION }}
          draft: true
          prerelease: false
          body_path: ${{ steps.changelog.outputs.CHANGELOG_FILE }}

  build-tauri:
    needs: create-release
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          # macOS builds
          - platform: macos-latest
            target: aarch64-apple-darwin
            name: macOS-arm64
          - platform: macos-latest
            target: x86_64-apple-darwin
            name: macOS-x64
          # Windows build
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
            name: Windows-x64
          - platform: ubuntu-24.04
            target: x86_64-unknown-linux-gnu
            name: Linux-x64

    runs-on: ${{ matrix.platform }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Setup Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          key: ${{ matrix.target }}

      - name: Install Linux dependencies
        if: runner.os == 'Linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential \
            pkg-config \
            libglib2.0-dev \
            libgtk-3-dev \
            libwebkit2gtk-4.1-dev \
            libayatana-appindicator3-dev \
            librsvg2-dev \
            libssl-dev \
            patchelf
          pkg-config --modversion glib-2.0
          pkg-config --modversion gobject-2.0
          pkg-config --modversion gio-2.0

      - name: Install frontend dependencies
        working-directory: apps/tars-desktop
        run: bun install

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # Updater signing key
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          # macOS code signing
          APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
          APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
          APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
          # macOS notarization
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        with:
          projectPath: apps/tars-desktop
          args: --target ${{ matrix.target }}
          updaterJsonKeepUniversal: true

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: artifacts-${{ matrix.name }}
          path: |
            target/${{ matrix.target }}/release/bundle/**/*.dmg
            target/${{ matrix.target }}/release/bundle/**/*.app.tar.gz*
            target/${{ matrix.target }}/release/bundle/**/*.exe
            target/${{ matrix.target }}/release/bundle/**/*.msi
            target/${{ matrix.target }}/release/bundle/**/*.deb
            target/${{ matrix.target }}/release/bundle/**/*.AppImage
            target/${{ matrix.target }}/release/bundle/**/*.rpm
            target/${{ matrix.target }}/release/bundle/**/latest.json
          if-no-files-found: warn

  publish-release:
    needs: [create-release, build-tauri]
    permissions:
      contents: write
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          pattern: artifacts-*
          path: artifacts
          merge-multiple: false

      - name: Generate latest.json and Prepare Assets
        run: |
          mkdir -p release-assets
          
          # Determine TAG_NAME and Version
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            TAG_NAME="v${{ inputs.version }}"
            VERSION="${{ inputs.version }}"
          else
            TAG_NAME="${{ github.ref_name }}"
            VERSION="${TAG_NAME#v}"
          fi
          
          REPO="${{ github.repository }}"
          BASE_URL="https://github.com/$REPO/releases/download/$TAG_NAME/"
          echo "Base URL: $BASE_URL"
          echo "Version: $VERSION"
          
          # Initialize platforms object
          echo "{}" > platforms.json
          
          # Function to process updater artifacts
          # Usage: process_artifact <dir_pattern> <platform_key> <file_extension> <rename_suffix>
          process_artifact() {
            local dir_pattern=$1
            local platform_key=$2
            local ext=$3
            local suffix=$4
            
            # Find the directory matching the pattern
            local source_dir=$(find artifacts -type d -name "$dir_pattern" | head -n 1)
            
            if [ -z "$source_dir" ]; then
              echo "Warning: Directory matching '$dir_pattern' not found."
              return
            fi
            
            echo "Processing $platform_key from $source_dir..."
            
            # Find signature file
            local sig_file=$(find "$source_dir" -name "*${ext}.sig" | head -n 1)
            
            if [ -n "$sig_file" ]; then
              local asset_file="${sig_file%.sig}"
              local filename=$(basename "$asset_file")
              local sig_content=$(cat "$sig_file")
              
              # Rename logic
              if [ -n "$suffix" ]; then
                # Assume filename format TARS.ext or TARS_ver.ext
                # We want TARS_suffix.ext or TARS_ver_suffix.ext
                # Simple approach: Prepend suffix to extension? 
                # Or just construct TARS_${suffix}${ext} if it matches TARS${ext}
                # Let's use a safe rename: insert suffix before first dot or append?
                # For macOS .app.tar.gz, we want TARS_${suffix}.app.tar.gz
                
                if [[ "$filename" == "TARS.app.tar.gz" ]]; then
                   local new_filename="TARS_${suffix}.app.tar.gz"
                else
                   # Fallback: append suffix
                   local new_filename="${filename%.*}_${suffix}.${filename##*.}"
                fi
                
                cp "$asset_file" "release-assets/$new_filename"
                cp "$sig_file" "release-assets/$new_filename.sig"
                filename="$new_filename"
              else
                cp "$asset_file" "release-assets/"
                cp "$sig_file" "release-assets/"
              fi
              
              local url="$BASE_URL$filename"
              
              # Add to platforms.json
              jq --arg k "$platform_key" --arg s "$sig_content" --arg u "$url" \
                 '.[$k] = {signature: $s, url: $u}' platforms.json > platforms.tmp && mv platforms.tmp platforms.json
            else
              echo "No .sig file found in $source_dir"
            fi
          }
          
          # Process artifacts for each platform
          # Note: Adjust extensions based on what build-tauri outputs. 
          # Assuming standard Tauri v2 outputs.
          
          process_artifact "artifacts-macOS-arm64" "darwin-aarch64" ".app.tar.gz" "aarch64"
          process_artifact "artifacts-macOS-x64" "darwin-x86_64" ".app.tar.gz" "x64"
          process_artifact "artifacts-Linux-x64" "linux-x86_64" ".AppImage.tar.gz" "" # Check if AppImage is gzipped? Usually .tar.gz for updater
          process_artifact "artifacts-Windows-x64" "windows-x86_64" ".msi.zip" "" # Usually zipped for updater
          
          # Fallback check: Tauri might output just .AppImage.sig or .msi.sig if configured differently?
          # If previous calls failed, try alternative extensions
          if ! jq -e '.["linux-x86_64"]' platforms.json >/dev/null; then
             process_artifact "artifacts-Linux-x64" "linux-x86_64" ".AppImage" ""
          fi
          if ! jq -e '.["windows-x86_64"]' platforms.json >/dev/null; then
             process_artifact "artifacts-Windows-x64" "windows-x86_64" ".msi" ""
             # And check for .nsis.zip
             if ! jq -e '.["windows-x86_64"]' platforms.json >/dev/null; then
                process_artifact "artifacts-Windows-x64" "windows-x86_64" ".nsis.zip" ""
             fi
          fi
          
          # Generate latest.json
          jq -n --arg v "$VERSION" \
                --arg n "See release notes" \
                --arg d "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                --slurpfile p platforms.json \
                '{version: $v, notes: $n, pub_date: $d, platforms: $p[0]}' > release-assets/latest.json
          
          echo "Generated latest.json:"
          cat release-assets/latest.json
          
          # Copy all other assets (DMGs, EXEs, etc) to release-assets
          # Use -n (no clobber) to avoid overwriting the renamed files
          find artifacts -type f ! -name "latest.json" -exec cp -n {} release-assets/ \; || true
          
          echo "Final Assets:"
          ls -lh release-assets/

      - name: Upload Release Assets
        uses: softprops/action-gh-release@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          files: release-assets/*
          tag_name: ${{ github.event_name == 'workflow_dispatch' && format('v{0}', inputs.version) || github.ref_name }}
          draft: false